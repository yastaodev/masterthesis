

!!!!!!!!!!!!! Alle README anpassen vor der Abgabe
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1

Conversion of Method Arguments:
    https://www.graalvm.org/22.0/reference-manual/js/JavaInteroperability/#conversion-of-method-arguments
Selection of Method:
    https://www.graalvm.org/22.0/reference-manual/js/JavaInteroperability/#selection-of-method
Exceptions:
    https://www.graalvm.org/22.0/reference-manual/js/JavaInteroperability/#exceptions

Input: Light years/Kilometers
Convert light years to kilometers:
Convert kilometers to light years:
    Use Java.Type(java.math.BigInteger) to calculate the huge distances to galaxies in Kilometers
    Use Java.Type(java.io.File) to write the result into a file
Find out how long a Human, a Cheetah, a Train, a Airplane need to get to the target
Show the comparison on an R graph
Print the conversion result and the svg to a pdf using NodeJS

# Besonderheit: Hier wird statt einen Methodenaufruf, direkt der Datentyp aus Java verwendet
    Wird zu String umgewandelt, da sonst zu Datenverlust führen kann
# Frage: Was ist nun die Testeinheit?
Hier
Für die Präsentation: Wie man sieht, es gibt hier keine einzige Java-Klasse, trotzdem können wir auf Java Funktionen zugreifen

https://semaphoreci.com/community/tutorials/getting-started-with-node-js-and-mocha
Mocha is BDD
We'll install our testing framework, and an expectation library called Chai that serves as a nice replacement for Node’s standard assert function.
$ npm install --save mocha chai
Note that we are using the --save option to automatically save these dependencies in our package.json file.
During the server testing phase, we will need a way to send HTTP requests. Request is an excellent choice.
Finally, we will also need the Express package that defines a simple DSL (domain-specific language) for routing and handling incoming HTTP
requests.
The following command is used to invoke the Mocha binary installed locally in the ./node_modules directory:
$ npx mocha --reporter spec


Ausführung mit npm nutzt das native Image: Startup schnell, aber keine Graal-JIT-Compiler
    mit npm --jvm: Startup langsam, dafür JIT-Kompilierung
    Polyglot funzt nur mit --jvm in JVM Mode oder --polyglot in Native mode

## Wenn für Java JUnit quasi Standard ist, ist bei Node/JS viel Konkurrenz: Mocha, Jest, Jasmine, etc.

# In der Implementierung habe ich mit Absicht den kleinen R-Snippet eingebettet und nicht outsourced.
Hier merkt man beim Testen, dass:
    Entweder das erzeugte Bild vergleichen bzw. den Hash davon: Hier hat man keinen Zugriff auf die Interna des R-Codes (Black Box)
    Oder den Snippet im Test einbetten und polyglot aufrufen, damit man Zugriff auf die Interna erlangt

# Es wird der JS String noch mal in R Double umgewandelt

# NodeJS kann Datei mit dem Default-OS-Programm nicht ohne Weiteres öffnen, daher greifen wir noch mal auf Java zu

# Hier kann man sogar in JS mit Java-Klassen und Objekten arbeiten, als wären sie die eigenen

# npm test -> TypeError: Access to host class java.math.MathContext is not allowed or does not exist
  npm --jvm test -> Error: No language for id R found. Supported languages are: [js]
  npm --polyglot test -> Error: No language for id R found. Supported languages are: [js]
  npm --polyglot --jvm test -> Error: No language for id R found. Supported languages are: [js]

## Known Bugs:
# export NODE_POLYGLOT_OPTIONS=--polyglot (https://github.com/oracle/graaljs/issues/364)

#
//1. Approach R-Test ignorieren: Nur das Bild oder die Hashes vergleichen
//2. Approach R-Test als Snippet einbetten und evaluieren:
    TestRunner von Mocha zeigt dass Test erfolgreich ist, obwohl das nicht der Fall ist
    Daher den Rückgabewert, sowie den Stacktrace muss man lesen können und an Mocha weitergeben
    capture.output in R, Array als Rückgabewert, ANSI-Colors escapen, True/false extrahieren
    2.a. R-File separat: Vorteil: lässt sich besser debuggen
//3. Approach R-Test nicht polyglot testen, sondern fastR als separater Prozess aufrufen und den Test durchführen
# Beim 3. Approach, nicht im polyglotten Kontext, also R-Tests im separaten Prozess machen nativ mit FastR, fragt man sich ob das Sinn macht, da
verschiedene Umebung zu unterschiedlichen Ergebnissen führen kann.
    Vorteil aber: man kann Test einfach ausführen, man muss nicht output capture und wrapper-Funktionen einbauen
    Nachteil: Ausführung aus Node.Js / Mocha heraus gibt keine Rückmeldung?
//4. Approach Mocks benutzen

## VS Code GraalVM Extension zeigt String-Snippets in Farben, unterstützt das Debugging nicht nur im Snippet sondern auch im File außerhalb

## Aktuell ist beste Unterstützung nur bei VS code
Java calls C and C++
    . C: Addition/Substraktion
    . C++: Multiplikation/Division
    https://chrisseaton.com/truffleruby/tenthings/
Bewusst redimentäre und simple Beispiele, um nicht mit Zeigern und Memory Management zu hantieren
Dynamic languages like JavaScript usually access object members by name. Since normally names are not preserved in LLVM bitcode, it must be
compiled with debug information enabled (the LLVM toolchain shipped with GraalVM will automatically enable debugging information).
https://www.graalvm.org/22.1/reference-manual/llvm/Interoperability/

Besonderer Fall, da LLVM ein Zwichenformat ist
There is one member of the GraalVM language family that is a bit special. While all the aforementioned languages are managed, so the language
runtime manages all memory requirements, the LLVM runtime executes LLVM bitcode, which is unmanaged. That means there is no garbage collector
that frees the memory automatically. Instead, users get their hands on raw pointers and need to maintain them manually. Also, arrays are not
bounds-checked. The programmer is responsible for checking sizes.

Im Gegensatz zu den interpretierten Sprachen(JS, Python, R, Ruby, etc.), wo man das Testen in verschiedenen Sprachen mixen konnte, ist es hier
anders, da C/C++ kompilierte Sprachen sind.
    Es mus also immer ein kompilierte Bitcode-File vorhanden sein. Dieses wird als Input eingegeben.
    Müssen wie zwei verschiedene Projekte betrachtet werden.
    Auf Java Seite kann nur das Ergebnis des LLVM-Output abgefragt und gecheckt werden.
    Keine Chance auf die Interna vom C++-Programm zu zugreifen.
    Die beiden Riesen: zwei konkurrierende GPLs welche die SW-Welt dominierten und religiöse Kriege auslösten
    C++ Progs von Java aufrufen und umgekehrt

It provides an implementation of the lli tool to directly execute programs from LLVM bitcode. The LLVM runtime is written in Java on top of the
Truffle Language Implementation framework. In contrast to static compilation that is normally used for LLVM based languages, LLI first interprets
the bitcode and then dynamically compiles the hot parts of the program using the GraalVM compiler. You can execute C/C++, Rust and any programming language that can be compiled to LLVM bitcode by the LLVM front end such as clang.

Um das C++ Programm zu kompilieren, muss man den mitgelieferten Compiler nutzen:
$LLVM_TOOLCHAIN/clang++ -fPIC -shared $SCRIPT_DIR/prime.cpp -lpolyglot-mock -o lib/prime.so
    mit -shared: signalisiert man, das man ein shared object erzeugen möchte, dessen Funktionen von außerhalb aufgerufen werden sollen
    mit polyglot-mock: library defines the polyglot API functions used in the example
    mit -fPIC ist notwendig, sonst kompiliert das Programm nicht: Position Independent Code means that the generated machine code is not
    dependent on being located at a specific address in order to work.
Um die Polyglot API im C++ Programm anzubinden, muss man #include <graalvm/llvm/polyglot.h> hinzufügen
Die Funktion kann aber nicht aufgerufen werden. Erst wenn sie in der Main-Methode durch polyglot_export("prime", &prime); exportiert werden kann.
Die Typkonversionen laufen im Hintergrund
return polyglot_from_string(result.c_str(), "ascii"); sonst funktioniert nicht wegen java.lang.ClassCastException: class com.oracle.truffle.llvm.runtime.debug.type.LLVMSourceStructLikeType cannot be cast to
                                                                                     class com.oracle.truffle.llvm.runtime.debug.type.LLVMSourceClassLikeType



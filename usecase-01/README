In diesem Fall ist es einfach: kleine Funktionen, man kann einfach die JS Funktionen in Java Funktionen wrappen
und den Rückgabewert der Java-Funktion prüfen.
Testeinheit ist die einzelne Methode

Anders sieht es aus, wenn die aufgerufenen JS Funktionen lang und kompliziert sind. Die muss man dann selbst testen.
Die Frage ist:
    1. Testet man sie in JS mit JS-Tools?
    2. Oder man nutzt Polyglot-API in JUnit und ruft die einzelnen JS-Funktionen als Members auf
        bedeutet: JEDES MAL muss der Context neu erstellt werden
        dafür hat man aber das vertraute Tooling.

Was ist wenn die Tests bereits in der Gastsprache existieren?
Wie und wo führt man sie aus?

### Erklaeren CommonJS Modules und ES Modules, und experimentelle Funktion require

## Probleme mit den Strings, wie bei Reflection (Am Besten die Probleme der Reflection wiedergeben): z.B. wie sieht es aus wenn der Name der
Funktion/Member sich ändert? Von der IDE bekommt man keinen Hinweis. No automatic error checking
    Außerdem bekommt man keine Autocompletion, wenn z.B. Methoden von java.math.BigInteger in Javascript-Code
    z.B. hier erkennt die IDE die Methode multiply nicht and keeps showing annoying warnings
        console.log(new BigIntegerClass("10").multiply(new BigIntegerClass(lyToKmAsString)));
## Probleme mit dem Refactoring: Riesenproblem
## Probleme mit den Exceptions: kommen nicht durch, können nicht geparst/übersetzt werden, steht sowas: Man kann damit nicht viel anfangen
unknown:0
unknown
^
[Error: parse exception] oder
[Error: Error: object 'Objects' not found] oder
Error: the object {} was thrown, throw an Error :)


## Probleme mit experimentellen Features: Compiler, Machine CPU not supported,etc, manches funzt nicht mit native image distributioninsta
## Probleme: Ganz viele Packages müssen installiert werden, z.B. bei ggplot2, fast eine Stunde um weitere Dependencies zu installieren
    By Python und R: Ubuntu-Pakete mussten installiert werden, um irgendwelche Funtkionen nutzen zu können

## Ich habe keine einzige Quelle gefunden, die das Testen von polyglotten Apps zeigt, no academic research
    ## Stattdessen Focus auf Unit-Tests für Native Images



# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Siehe Abschnitt 5.2 in http://theuntitledblog.com/wp-content/uploads/2008/08/polyglot_programming-a_business_perspective.pdf
Very important approach: Ist das nicht besser, wenn die Tests so klein und übersichtlich sind und die Ausgaben aussagekräftig sind?
The Ruby code is much more concise, and the intent of the code is much clearer,
because the programming language provides the freedom to remove unnecessary syntax.
Because the testing code will not be run in production, the runtime performance of the language used is not important, but rather programming productivity. Using an interpreted language also enables new tests to be run without
compilation.
Probleme: Debuggen in Guest language

# Dieses Beispiel ist zum Einstieg, daher einfach und minimal gehalten + Modul hat keine weiteren Abhängigkeiten

#   Vorteil: Library ist klein, useful, minimaler Aufwand. Diesen Vorteil weiß ein Java-Entwickler nicht zu schätzen, wohl aber ein PL-SQL oder
COBOL oder wer auch immer + Viele Funktionen, die im Web nützlich sind (z.B. isStrongPassword). Man stellt sich vor eine Oracle DB und ein
Batch-Skript vor, das alle Emails, IBANs, etc. validiert. Enormer Gewinn
    Nachteil: Module muss zuerst installiert werden, neuer Package Manager, Sicherheitsaspekte, etc.

# Keine Notwendgigkeit, Tests in JS zu schreiben.


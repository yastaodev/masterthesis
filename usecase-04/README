Sonderfall: Java and C shared libraries
Ein Beispiel dafür, dass man gar keine Wahl hat: Man ist gezwungen die Tests unabhängig voneinander in den jeweiligen Sprachen zu schreiben
Während man bei anderen Usecases die Möglichkeit hat, hybride oder separate Tests zu schreiben, bleiben bei diesem Usecase nicht viele Optionen
offen. weil die Shared Library binär ist und nur importiert werden kann. Man muss sich drauf verlassen, dass die importierte Library getestet ist
Auf die Tests in C werde ich verzichten, da ich kein ausreichendes Know-How habe.
Sehr wichtig: Die Tests in Java müssen mit dem JUnit for native images getestet werden. Das ermöglicht unter realen Bedingungen zu testen.
Erklären JUnit for native images

native-image kann nicht nur Executables erzeugen, sondern auch sog. shared Libraries

Type Conversion: Im Package org.graalvm.nativeimage.c findet man zahlreiche Optionen um C-Typen abzubilden, z.B CEntryPoint, CStruct, etc.

!!!!!!!!!! Achtung: Referenzen nicht vergessen

Dieser Luxus geht nur mit der Einschränkung, dass es kein "Write Once Run Anywhere" mehr gibt. Man muss für jede Platform kompilieren

https://chrisseaton.com/truffleruby/tenthings/
Java Code as shared/native library
    Java has a great ecosystem of many very high quality libraries, which often aren’t available in other ecosystems, including native
    applications as well as other managed languages. If you wanted to use a Java library from a native application you could embed the JVM but
    this gets very large and complicated very quickly.
    GraalVM lets you take Java library, either off-the-shelf or one you’ve written yourself, and compile it to a standalone native library for
    use from other native languages. As with our native compilation before, they don’t require a JVM to run.


Note that this document describes the opposite of what is commonly done via JNI: usually low-level system operations are implemented in C and
invoked from Java using JNI.

# https://nirvdrum.com/2022/05/09/truffle-language-embedding.html
GraalVM’s Native Image tool can build native executables and native shared libraries from Java code. By default, these binaries will have a
dependency on your system’s libc and implementations, but you can instruct Native Image to statically link in libc and zlib libraries if you
have them, leaving you with a binary that has no external dependencies. In effect, you can use Java just as you would any other ahead-of-time
(AOT) compiled language. In contrast to C/C++, Rust, or other similar systems languages, you still have access to the Java VM facilities such as
 Java’s IO abstraction and garbage collection (GC). However, the VM facilities are not provided by HotSpot, but rather a new VM written
 specifically for Native Image binaries called SubstrateVM.

 Just to reiterate, the binary generated by Native Image does not include a JVM, so it can’t support functionality like dynamically loading
 classes from a JAR.

# Allgemeines Problem: Die Dokumentation der GraalVM ist noch nicht vollständig, mangelhaft

# Ein weiterer riesiger Schritt Richtung polyglot: Shared Lib in Java geschrieben, kann in C/C++, Go, Rust, -ruby, Python, etc. eingebunden
werden

# --shared Option erklären
# IsolateThread erklären

Isolates erklären: Every function you would like to expose in a Native Image shared library using @CEntryPoint must have an IsolateThread as its
first parameter and every call to that method through the shared library must supply a Graal Isolate pointer as its first argument.

native-image --shared -H:Name=libdistance -cp target/classes
export LD_LIBRARY_PATH=<WORKING_DIRECTORY>
export GOPATH=<WORKING DIRECTORY>
export GOBIN=$GOPATH/bin
(in src folder) go install
./out
Code-Snippets von Stackoverflow und Tutorials

# Siehe Kommentare in der Main Klasse

#Erklären was eine VENV ist

# NumPy is the most popular library for Python and that is for a reason. I didn't want to use it, because it needs some advanced knowledge to get
 it understood.
However I introduced a little example to show how it works.
# I use Maven to get all required packages and dependencies installed, just like we do with Java.
# To make a Python application distributable it's recommended to use venv (virtual environment). The latter is a collections of scripts and
symbolic links.

Let’s go through this. First, we create a Context.Builder and request the "python" language to be available. (More languages are implicitly enabled. For example, Python depends on the "llvm" language for its C extension support.) Next, we set the flag to allow all access to native code, the file system, etc. It's ok for now to start with all permissions to get things going and whittle down to what we need later.

The two option calls go hand in hand and need a bit more Python background. The Python executable on your machine always, as part of its startup code, executes the equivalent of import site. The site module is responsible for setting up the package paths for user and system packages, as well as discovering if the executable is inside a virtual environment and then setting the package paths accordingly.

#Schwierigkeiten:
    ##Kryptische Fehlermeldungen der Gastsprachen
    ##Man muss sich mit den Eigenheiten der einzelnen Sprachen/Modulsysteme/Build-Prozesse/TestLibraries auseinandersetzen
    ##Libraries die nicht mehr kompatibel sind, etc.
    ## I had problems with resolving paths, etc.
    ##Packages/Module that cause problems. For many of them there is already patched versions, but not for all..
# I have to explain what is a python virtual environment and why to use it

# Man muss Python-Funktionen annotieren, die man exportieren möchte, sonst sind sie in den PolyglotBindingsMemberKeys nicht enthalten

# Asserts:
    - Image checksum, size, colors are exactly the same
# Hier sollen Tests aus Java angestoßen werden, dann die von Python, dann zurück
    Java Test triggert Python Test, und wenn dieser fertig ist, der gibt sein Ergebnis an den JavaTest zurück.
    Wenn Python Test fehlschlägt, dann soll der JavaTest auch fehlschlagen
    Wenn der UnitTest in der Gastsprache (z.b. NodeJs) fehlschlägt, wie bekommt man das ganze Ergebnis (Bei mocha z.B. sehr schön formatiert)
    Wenn Test fehlschlägt, führt man weiter aus, oder bricht man das ganze ab

# Eine wichtige Einschränkung: Ich hatte ien ImageUtils-Klasse, die nur statische Methoden hat. Das funktioniert aber nicht gut: statische
Methoden haben keinen Zustand, daher muss der Context jedesmal neu gebildet werden, und das ist sehr teuer. Das will man natürlich nicht. Deshalb
 war ich GEZWUNGEN, einen Processor daraus zu machen, der den Context als Zustand hält. Vlt. ist das ein Grund warum lieber Python für die Tests
 nutzen.. weiß ich nicht.
/opt/work/workspaces/idea/master-thesis/usecase-03/src/test/resources
 # In der Regel gibt es für jede Sprache eine geeignete IDE, z.B. PyCharm für Python, RStudio für R usw. Entwickeln von Python-Code in Eclipse
 oder in Intellij IDEA bringt nicht dieselbe User Experience, trotz Plugins usw. Genauso macht das Java Coding in VS Code nicht so viel Spaß. Es
 gibt einfach für jede Sprache eine speziell eingeschnittene IDE.

 # Meine Lieblings-IDE bietet nicht den besten Support für Python Tests, deshalb musste ich zu VS Code switchen, um die Pythons Test auszuführen.

 # Tests im Terminal ausführen: python3 -m unittest image_utils_test.py

 # Man sieht bspw. anhand von test_create_empty_image, dass der Test mit der entsprechenden Sprache mehr Möglichkeiten anbietet: Hier z.B. konnte
  ich auf die NumPy Bibliothek zugreifen und diverse Vergleiche machen.
    Mit Java hat man nur die Möglichkeit die Endergebnisse bzw. Erzeugnisse zu vergleichen, sei es mit Hash oder was anderes.
        Es sei denn man nutzt die Polyglot-API, aber das ist wiederum zu viel des Guten.

# Das Aufrufen von Py Tests mit python erspart mir die ganzen Inkompatibilitäten und Einschränkungen von GraalVM Polyglot API, bzw. graalpython
specific patches

# Problematisch: Für jeden Import musste ich tausende von Bibliotheken installieren, teils manuell, C-Libraries für Ubuntu etc.
    Ich habe den Überblick verloren, was ich alles installieren musste. Deshalb ist die pom.xml nicht relevant
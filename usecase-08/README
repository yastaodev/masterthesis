Java on Truffle

There are three ways to run Java applications using GraalVM.
    1. on the JVM (No need to consider)
    2. in Native Image (Already discussed)
    3. on Truffle

running on top of HotSpot only works on Linux (with glibc). Running as part of a native executable works on Linux, Windows, and macOS but it
currently limited to one context.

It features complete meta-circularity: it can run itself any amount of layers deep, preserving all the capabilities (Unsafe, JNI, Reflection...)
of the base layer. Running HelloWorld on three nested layers of Espresso takes ~15 minutes.

Integration Test shows if GraalVM could evaluate the context successfullynested

Another advantage is that the code is nice, familiar and understandable to Java developers. Consider going to the GitHub repository and looking at the source code for it. Your day-to-day tools work for it, your IDE supports it, you can explore the code base the same way you explore any other Java dependecies. This transparency and familiarity should allow Java on Truffle be efficient at rapidly changing to the better.

Benefits: See https://www.graalvm.org/22.0/reference-manual/java-on-truffle/

What useful for this project is:
    - run Java bytecodes in a separate context from the host Java VM. It can run either a Java 8, Java 11, Java 17 guest or host JVM. In other
    words, you can embed a Java 8 context in a Java 11 application, by using GraalVM’s Polyglot API.
    - run in the context of a native executable while still allowing dynamically-loaded bytecodes.

If you are using the native configuration, you will need to use the --polyglot flag to get access to other languages.

!!! IMPORTANT: *Java on Truffle does not support evaluation (.eval) of Java sources.

Java on Truffle does not support the Polyglot API yet. However, it provides a guest Java Polyglot API, described in polyglot.jar. For more
information, see Interoperability with Truffle Languages.

Das Problem hier: Im normalen Java Code wird der Compiler jedes Mal über FileInputStream meckern, bis ein try-catch oder throws zum Code
hinzugefügt werden. Bei Espresso hingegen, kannst du schreiben was du möchtest, da ist keine CheckedException nötig, weil alles String ist.

-truffle -XX:+IgnoreUnrecognizedVMOptions

Methoden aufrufen:
    - Klassenmethoden: context.getBindings().getMember(<class_name>).invokeMember(<method_name>)
    - Objektmethoden: context.getBindings().getMember(<class_name>).getMember("class").invokeMember(<method_name>)
Wenn kein Overloading stattfindet, dann kann man einfach den Methodennamen verwenden. Sonst muss man den Method descriptor angeben.
Method descriptor to avoid overloading ambiguity:
    Call String.valueOf: java_lang_String.invokeMember("valueOf/(I)Ljava/lang/String", 42);

    printHostJava und printGuestJava als Beispiel in der Ausarbeitung zeigen

Wer noch an CORBA oder SOAP hängt und es benutzen möchte, der kann das auf diesem Weg noch tun. Die Klassen kann man wieder beschwören.
Removed methods/classes can be called
Beispiel für Klasse vorhanden aber Methode nicht mehr: java.lang.Thread.destroy()
                                                       java.lang.Thread.stop(java.lang.Throwable)

Definiert welche Java-Distro zu nutzen ist
.option("java.JavaHome","/opt/work/tools/sdkman/candidates/java/8.0.242.hs-adpt/")

Es können keine Java-Sources geladen werden, sondern es müssen über den ClassLoader (via Polyglot Context) geladen werden

Die Use-Cases kurz erläutern vorstellen:
    - Mixing AOT an JIT :Jshell (native + dynamic)
    - Removed Features https://www.dariawan.com/tutorials/java/java-11-remove-java-ee-and-corba-modules-jep-320/
    - Im selben Heap mit anderen polyglot
    - Advanced class redefinition: during debugging add & remove methods, constructors, modifiers, etc.

Offenbar funktioniert nicht das Aufrufen von Methoden, die removed sind.
Also es schon die ganze Klasse removed sein, damit sie funktioniert.
    Siehe stopJava8Thread & destroyJava8Thread

Interessant ist vor allem zu wissen wie werden dann Klassen vererbt, Methoden überschrieben, Anonymous Klassen erstellt, AOP, Proxying, etc.?
Das sind alles Dinge, von denen viele Frameworks Gebrauch machen, u.a. JUNIT

Um Threads benutzen zu können muss man diese Option hinzufügen:                 .option("java.MultiThreaded", "true")

Wenn man nur an das Ergebnis einer Funktion interessiert ist, dann muss man keine Tests mit Espresso Code schreiben.
Wenn man die innere Logik testen möchte, dann führt kein Weg an Espresso vorbei, zumal die Argumente der Funktionen in Espresso value (foreign)
objects konvertiert werden müssen.
Außerdem will man ja auch prüfen, ob die Konvertierung der Argumente überhaupt funktioniert hat.

- testparseBoolean,testparseDouble, etc. keine Notwendigkeit für Polyglot-API
- testStartJava8ThreadAsGuest: Polyglot-API nutzen, um Methoden aufrufen zu können
- testStartJava8ThreadAsHost: andere Herangehensweise: Value as Runnable, hier ganz normal die Methoden des Hosts aufrufen
- stopJava8Thread(Value thread, Value throwable) hat ein Polyglot Value als Parameter, dernur erzeugt werden kann, wenn der Tester selbst ein
Context erzeugt und aktiv die Polyglot-API nutzt, da es keine Methode in der zu testende Klasse gibt, die bequem ein Throwable erzeugt und
zurückk gibt.
    - Im Gegensatz zu createJava8Thread, die ein fertiggestelltes Objekt zurückgibt.
    - Also muss man im Voraus klarstellen, ob man Espresso (d.h. erzeugen von Objekten, Aufrufe, etc.) auch in den Tests nutzen möchte oder nicht.
    - Wenn man das nicht möchte, dann muss die Basisklasse Factories zur Verfügung stellen, die fertiggestellte Objekte erzeugt und weitergibt.
        - Da stellt sich wiederum die Frage, wie testet man diese Factories. Also muss man schon ein Kompromiss finde.
    - die Mthode kann also nicht getestet werden, da Value throwable nicht erzeugt werden kann (Wir simulieren nuur das Szenario, dass es nicht
    möglich ist, sonst kann man ja den Context erzeugen, aber nehmen wir an, die Test-Umgebung lässt dies nicht zu.)
- testDestroyJava8ThreadNotPossible: Methode wurde removed von der Klasse Thread, daher selbst wenn sie als Member in der Liste erscheint, kann
sie nicht ausgewertet/ausgeführt werden. Ursache noch nicht bekannt. Die Fehlermeldung ist nicht vielsagend.


Die Fälle, die ich nicht testen konnte, verlinken: Springt den Rahmen. Die Teststrategien unterscheiden sich nicht viel
    - COBOL
    - C#, VB, CIL
    - Oracle DB Server
    - Smalltalk


